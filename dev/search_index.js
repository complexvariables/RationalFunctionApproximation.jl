var documenterSearchIndex = {"docs":
[{"location":"functions/","page":"Functions","title":"Functions","text":"CurrentModule = RationalFunctionApproximation","category":"page"},{"location":"functions/#Functions-and-types","page":"Functions","title":"Functions and types","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"","category":"page"},{"location":"functions/","page":"Functions","title":"Functions","text":"Modules = [RationalFunctionApproximation]","category":"page"},{"location":"functions/#RationalFunctionApproximation.Approximation","page":"Functions","title":"RationalFunctionApproximation.Approximation","text":"Approximation (type)\n\nApproximation of a function on a domain.\n\nFields\n\noriginal: the original function\ndomain: the domain of the approximation\nfun: the barycentric representation of the approximation\nprenodes: the prenodes of the approximation\n\n\n\n\n\n","category":"type"},{"location":"functions/#RationalFunctionApproximation.Barycentric","page":"Functions","title":"RationalFunctionApproximation.Barycentric","text":"Barycentric (type)\n\nBarycentric representation of a rational function.\n\nFields\n\nnode: the nodes of the rational function\nvalue: the values of the rational function\nweight: the weights of the rational function\nwf: the weighted values of the rational function\nstats: convergence statistics\n\n\n\n\n\n","category":"type"},{"location":"functions/#RationalFunctionApproximation.Barycentric-2","page":"Functions","title":"RationalFunctionApproximation.Barycentric","text":"Barycentric(node, value, weight, wf=value.*weight; stats=missing)\n\nConstruct a Barycentric rational function.\n\nArguments\n\nnode::AbstractVector: interpolation nodes\nvalue::AbstractVector: values at the interpolation nodes\nweight::AbstractVector: barycentric weights\nwf::AbstractVector: weights times values (optional)\nstats::ConvergenceStatistics`: convergence statistics (optional)\n\nExamples\n\njulia> r = Barycentric([1, 2, 3], [1, 2, 3], [1/2, -1, 1/2])\nBarycentric function with 3 nodes and values:\n    1.0=>1.0,  2.0=>2.0,  3.0=>3.0\n\njulia> r(1.5)\n1.5\n\n\n\n\n\n","category":"type"},{"location":"functions/#RationalFunctionApproximation.ConvergenceStats","page":"Functions","title":"RationalFunctionApproximation.ConvergenceStats","text":"ConvergenceStats{T}(bestidx, error, nbad, nodes, values, weights, poles)\n\nConvergence statistics for a sequence of rational approximations.\n\nFields\n\nbestidx: the index of the best approximation\nerror: the error of each approximation\nnbad: the number of bad nodes in each approximation\nnodes: the nodes of each approximation\nvalues: the values of each approximation\nweights: the weights of each approximation\npoles: the poles of each approximation\n\nSee also: approximate, Barycentric\n\n\n\n\n\n","category":"type"},{"location":"functions/#Base.values-Tuple{Barycentric}","page":"Functions","title":"Base.values","text":"values(r) returns the nodal values of the rational interpolant r as a vector.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.aaa-Tuple{AbstractVector{<:Number}, AbstractVector{<:Number}}","page":"Functions","title":"RationalFunctionApproximation.aaa","text":"aaa(z, y)\naaa(f)\n\nAdaptively compute a rational interpolant.\n\nArguments\n\ndiscrete mode\n\nz::AbstractVector{<:Number}: interpolation nodes\ny::AbstractVector{<:Number}: values at nodes\n\ncontinuous mode\n\nf::Function: function to approximate on the interval [-1,1]\n\nKeyword arguments\n\ndegree::Integer=150: maximum numerator/denominator degree to use\nfloat_type::Type=Float64: floating point type to use for the computation\ntol::Real=1000*eps(float_type): tolerance for stopping\nlookahead::Integer=10: number of iterations to determines stagnation\nstats::Bool=false: return convergence statistics\n\nReturns\n\nr::Barycentric: the rational interpolant\nstats::NamedTuple: convergence statistics, if keyword stats=true\n\nSee also approximate for approximating a function on a region.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.approximate-Tuple{Function, ComplexRegions.AbstractRegion}","page":"Functions","title":"RationalFunctionApproximation.approximate","text":"approximate(f, domain)\n\nAdaptively compute a rational interpolant on a curve, path, or region.\n\nArguments\n\nf::Function: function to approximate\ndomain: curve, path, or region from ComplexRegions\n\nKeyword arguments\n\ndegree::Integer=150: maximum numerator/denominator degree to use\nfloat_type::Type=Float64: floating point type to use for the computation\ntol::Real=1000*eps(float_type): relative tolerance for stopping\nisbad::Function: function to determine if a pole is bad\nrefinement::Integer=3: number of test points between adjacent nodes\nlookahead::Integer=10: number of iterations to determine stagnation\nstats::Bool=false: return convergence statistics with the approximation? (slower)\n\nReturns\n\nr::Approximation: the rational interpolant\n\nSee also Approximation, check, aaa.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.check-Tuple{RationalFunctionApproximation.Approximation}","page":"Functions","title":"RationalFunctionApproximation.check","text":"check(r)\n\nCheck the accuracy of a rational approximation r on its domain.\n\nArguments\n\nr::Approximation: rational approximation\n\nReturns\n\nτ::Vector: test points\nerr::Vector: error at test points\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.degree-Tuple{Barycentric}","page":"Functions","title":"RationalFunctionApproximation.degree","text":"degree(r) returns the degree of the numerator and denominator of the rational r.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.nodes-Tuple{Barycentric}","page":"Functions","title":"RationalFunctionApproximation.nodes","text":"nodes(r) returns the nodes of the rational interpolant r as a vector.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.rewind-Tuple{Barycentric, Integer}","page":"Functions","title":"RationalFunctionApproximation.rewind","text":"rewind(r, degree)\n\nRewind a Barycentric rational function to a lower degree using stored convergence data.\n\nArguments\n\nr::Union{Barycentric,Approximation}: the rational function to rewind\ndegree::Integer: the degree to rewind to\n\nReturns\n\nthe rational function of the specified degree (same type as input)\n\nExamples\n\njulia> r = aaa(x -> cos(20x), stats=true)\nBarycentric function with 25 nodes and values:\n    -1.0=>0.408082,  -0.978022=>0.757786,  -0.912088=>0.820908,  …  1.0=>0.408082\n\njulia> rewind(r, 10)\nBarycentric function with 11 nodes and values:\n    -1.0=>0.408082,  1.0=>0.408082,  -0.466667=>-0.995822,  …  0.898413=>0.636147\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.stats-Tuple{Barycentric}","page":"Functions","title":"RationalFunctionApproximation.stats","text":"stats(r) returns the convergence statistics of the rational interpolant r.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.weights-Tuple{Barycentric}","page":"Functions","title":"RationalFunctionApproximation.weights","text":"weights(r) returns the weights of the rational interpolant r as a vector.\n\n\n\n\n\n","category":"method"},{"location":"#Rational-function-approximation-in-Julia","page":"Home","title":"Rational function approximation in Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for RationalFunctionApproximation.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package uses the continuous form of the AAA algorithm to adaptively compute rational approximations of functions on intervals and other domains in the complex plane.  See AAA rational approximation on a continuum, which is to appear in SISC.","category":"page"},{"location":"#Approximation-on-[-1,-1]","page":"Home","title":"Approximation on [-1, 1]","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here's a smooth, gentle function on the interval -1 1:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using RationalFunctionApproximation, CairoMakie\nconst shg = current_figure\nf = x -> exp(cos(4x) - sin(3x))\nlines(-1..1, f)","category":"page"},{"location":"","page":"Home","title":"Home","text":"To create a rational function that approximates f well on this domain, we use the continuous form of the AAA algorithm:","category":"page"},{"location":"","page":"Home","title":"Home","text":"r = aaa(f)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The result is a type (19,19) rational approximant that can be evaluated like a function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(0.5) - r(0.5)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We see that this approximation has more than 13 accurate over most of the interval:","category":"page"},{"location":"","page":"Home","title":"Home","text":"lines(-1..1, x -> f(x)-r(x))","category":"page"},{"location":"","page":"Home","title":"Home","text":"The rational approximant interpolates f at greedily selected nodes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"x = nodes(r)\nscatter!(x, 0*x, markersize = 12, color=:black)\nshg()","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here's another smooth example, the hyperbolic secant function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"f = sech\nr = aaa(f)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can verify that this is accurate to 14 digits:","category":"page"},{"location":"","page":"Home","title":"Home","text":"x = range(-1, 1, 1000)\nextrema(f.(x) - r.(x))","category":"page"},{"location":"","page":"Home","title":"Home","text":"Since the sech function has poles in the complex plane, the rational approximant r will have corresponding poles:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DomainColoring\ndomaincolor(r, [-8, 8], abs=true)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The poles closest to the interval are found to about 10 digits, while more distant ones are less accurate:","category":"page"},{"location":"","page":"Home","title":"Home","text":"poles(r) / π","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here's an example with a more interesting structure of poles and zeros:","category":"page"},{"location":"","page":"Home","title":"Home","text":"f = x -> tanh(10*(x - 0.1)^2)\ndomaincolor(aaa(f), abs=true)","category":"page"},{"location":"#Approximation-on-other-domains","page":"Home","title":"Approximation on other domains","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The AAA algorithm can also be used to approximate functions on other domains as defined in the ComplexRegions package. For example, here's a function defined on the unit circle:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using RationalFunctionApproximation, CairoMakie, DomainColoring\nconst shg = current_figure\nf = z -> (z^3 - 1) / sin(z - 0.9 - 1im)\nr = approximate(f, unit_circle)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This approximation is accurate to 13 digits, as we can see by plotting the error around the circle:","category":"page"},{"location":"","page":"Home","title":"Home","text":"errorplot(r)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here is how the approximation looks in the complex plane (using black crosses to mark the poles):","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ComplexRegions, ComplexPlots\ndomaincolor(r, [-1.5, 1.5, -1.5, 1.5], abs=true)\nlines!(unit_circle, color=:white, linewidth=5)\nscatter!(poles(r), markersize=18, color=:black, marker=:xcross)\nlimits!(-1.5, 1.5, -1.5, 1.5)\nshg()","category":"page"},{"location":"","page":"Home","title":"Home","text":"Above, you can also see the zeros at roots of unity.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This function has infinitely many poles and an essential singularity inside the unit disk:","category":"page"},{"location":"","page":"Home","title":"Home","text":"f = z -> tan(1 / z^4)\nr = approximate(f, unit_circle)\ndomaincolor(r, [-1.5, 1.5, -1.5, 1.5], abs=true)\nlines!(unit_circle, color=:white, linewidth=5)\nshg()","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can request an approximation that is analytic in a region. In this case, it would not make sense to request one on the unit disk, since the singularities are necessary:","category":"page"},{"location":"","page":"Home","title":"Home","text":"r = approximate(f, unit_disk)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the result above, the approximation is simply a constant function, as the algorithm could do no better. However, if we request analyticity in the region exterior to the circle, everything works out:","category":"page"},{"location":"","page":"Home","title":"Home","text":"r = approximate(f, exterior(unit_circle))\nz, err = check(r)\nmaximum(abs, err)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We are not limited to intervals and circles! ","category":"page"},{"location":"","page":"Home","title":"Home","text":"import ComplexRegions.Shapes\nr = approximate(z -> log(0.35 + 0.4im - z), interior(Shapes.cross))\ndomaincolor(r, [-1.5, 1.5, -1.5, 1.5], abs=true)\nlines!(boundary(r.domain), color=:white, linewidth=5)\nshg()","category":"page"},{"location":"","page":"Home","title":"Home","text":"c = Shapes.hypo(5)\nr = approximate(z -> (z+4)^(-3.5), interior(c))\ndomaincolor(r, [-5, 5, -5, 5], abs=true)\nlines!(c, color=:white, linewidth=5)\nshg()","category":"page"},{"location":"#Unbounded-domains","page":"Home","title":"Unbounded domains","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It's also possible to approximate on unbounded domains, but this capability is not yet automated. For example, the function","category":"page"},{"location":"","page":"Home","title":"Home","text":"f = z -> 1 / sqrt(z - (-1 + 3im))","category":"page"},{"location":"","page":"Home","title":"Home","text":"is analytic on the right half of the complex plane. In order to produce an approximation on that domain, we can transplant it to the unit disk via a Möbius transformation phi:","category":"page"},{"location":"","page":"Home","title":"Home","text":"φ = Mobius( [-1, -1im, 1], [1im, 0, -1im])   # unit circle to imag axis\nz = discretize(unit_circle, ds=.02)\nfig, ax, _ = scatter(z, axis=(autolimitaspect=1, ))\nax.title = \"z\"\nax, _ = scatter(fig[1,2], φ.(z))\nax.title = \"φ(z)\"\nlimits!(-4, 4, -4, 4)\nshg()","category":"page"},{"location":"","page":"Home","title":"Home","text":"By composing f with phi, we can approximate within the disk while f is evaluated only on its native domain:","category":"page"},{"location":"","page":"Home","title":"Home","text":"r = approximate(f ∘ φ, interior(unit_circle))\ndomaincolor(r, [-2, 2, -2, 2], abs=true)\nlines!(unit_circle, color=:white, linewidth=5)\nscatter!(nodes(r.fun), color=:black, markersize=10)\nshg()","category":"page"},{"location":"","page":"Home","title":"Home","text":"Above, the black markers show the nodes of the interpolant. We can view the same approximation within the right half-plane by composing r with phi^-1:","category":"page"},{"location":"","page":"Home","title":"Home","text":"φ⁻¹ = inv(φ)\ndomaincolor(r ∘ φ⁻¹, [-8, 8, -8, 8], abs=true)\nlines!([(0, 8), (0, -8)], color=:white, linewidth=5)\nscatter!(φ.(nodes(r.fun)), color=:black, markersize=10)\nlimits!(-8, 8, -8, 8)\nshg()","category":"page"}]
}
