var documenterSearchIndex = {"docs":
[{"location":"functions/#Functions-and-types","page":"Functions","title":"Functions and types","text":"","category":"section"},{"location":"functions/","page":"Functions","title":"Functions","text":"","category":"page"},{"location":"functions/#RationalFunctionApproximation.Approximation","page":"Functions","title":"RationalFunctionApproximation.Approximation","text":"Approximation (type)\n\nApproximation of a function on a domain.\n\nFields\n\noriginal: the original function\ndomain: the domain of the approximation\nfun: the barycentric representation of the approximation\nallowed: function to determine if a pole is allowed\nprenodes: the prenodes of the approximation\ntest_points: test points where residual was computed\nhistory: all approximations in the iteration\n\n\n\n\n\n","category":"type"},{"location":"functions/#RationalFunctionApproximation.Barycentric","page":"Functions","title":"RationalFunctionApproximation.Barycentric","text":"Barycentric (type)\n\nBarycentric representation of a rational function.\n\nFields\n\nnode: the nodes of the rational function\nvalue: the values of the rational function\nweight: the weights of the rational function\nwf: the weighted values of the rational function\nstats: convergence statistics\n\n\n\n\n\n","category":"type"},{"location":"functions/#RationalFunctionApproximation.Barycentric-2","page":"Functions","title":"RationalFunctionApproximation.Barycentric","text":"Barycentric(node, value, weight, wf=value .* weight; stats=missing)\n\nConstruct a Barycentric rational function.\n\nArguments\n\nnode::Vector: interpolation nodes\nvalue::Vector: values at the interpolation nodes\nweight::Vector: barycentric weights\n\nKeywords\n\nwf::Vector = value .* weight: weights times values\n\nReturns\n\n::Barycentric: a barycentric rational interpolating function\n\nExamples\n\njulia> r = Barycentric([1, 2, 3], [1, 2, 3], [1/2, -1, 1/2])\nBarycentric function with 3 nodes and values:\n    1.0=>1.0,  2.0=>2.0,  3.0=>3.0\n\njulia> r(1.5)\n1.5\n\n\n\n\n\n","category":"type"},{"location":"functions/#RationalFunctionApproximation.DiscretizedPath-Tuple{Union{ComplexRegions.AbstractCurve, ComplexRegions.AbstractPath}, AbstractVector}","page":"Functions","title":"RationalFunctionApproximation.DiscretizedPath","text":"DiscretizedPath(path, s::AbstractVector; kwargs...)\nDiscretizedPath(path, n::Integer=0; kwargs...)\n\nDiscretize a path, keeping the option of future making local refinements.\n\nArguments\n\npath: a ComplexCurve or ComplexPath\ns: a vector of parameter values\nn: number of points to discretize the path\n\nKeyword arguments\n\nrefinement: number of refinements to make between consecutive points\nmaxpoints: maximum number of points ever allowed\n\nSee also collect, add_node!.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.RFIVector","page":"Functions","title":"RationalFunctionApproximation.RFIVector","text":"Sequence of rational interpolants produced by an iteration.\n\nFields\n\nnodes: vector of interpolation nodes\nvalues: vector of interpolation values\nweights: matrix of all weights (upper triangle)\nlen: the number of nodes for each approximation\nbest: the index of the best approximation\n\nSee also: approximate\n\n\n\n\n\n","category":"type"},{"location":"functions/#Base.collect","page":"Functions","title":"Base.collect","text":"collect(d::DiscretizedPath, which=:nodes)\n\nCollect the points and parameters of a discretized path.\n\nArguments\n\nd: a DiscretizedPath object\nwhich: return the nodes if :nodes, test points if :test, or all if :all\n\nReturns\n\nTuple of two vectors: parameter values and points on the path\n\nSee also add_node!, DiscretizedPath.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Base.values-Tuple{RationalFunctionApproximation.AbstractRationalInterpolant}","page":"Functions","title":"Base.values","text":"values(r) returns a vector of the nodal values of the rational interpolant r.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.Res-Tuple{Function, Number}","page":"Functions","title":"RationalFunctionApproximation.Res","text":"Res(r, z)\n\nReturns the residue of the rational function r at the point z.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.aaa-Tuple{AbstractVector{<:Number}, AbstractVector{<:Number}}","page":"Functions","title":"RationalFunctionApproximation.aaa","text":"aaa(y, z)\naaa(f)\n\nAdaptively compute a rational interpolant.\n\nArguments\n\ndiscrete mode\n\ny::AbstractVector{<:Number}: values at nodes\nz::AbstractVector{<:Number}: interpolation nodes\n\ncontinuous mode\n\nf::Function: function to approximate on the interval [-1,1]\n\nKeyword arguments\n\nmax_degree::Integer=150: maximum numerator/denominator degree to use\nfloat_type::Type=Float64: floating point type to use for the computation\ntol::Real=1000*eps(float_type): tolerance for stopping\nstagnation::Integer=10: number of iterations to determines stagnation\nstats::Bool=false: return convergence statistics\n\nReturns\n\nr::Barycentric: the rational interpolant\nstats::NamedTuple: convergence statistics, if keyword stats=true\n\nExamples\n\njulia> z = 1im * range(-10, 10, 500);\n\njulia> y = @. exp(z);\n\njulia> r = aaa(z, y);\n\njulia> degree(r)   # both numerator and denominator\n12\n\njulia> first(nodes(r), 4)\n4-element Vector{ComplexF64}:\n 0.0 - 6.272545090180361im\n 0.0 + 9.43887775551102im\n 0.0 - 1.1022044088176353im\n 0.0 + 4.909819639278557im\n\njulia> r(1im * π / 2)\n-2.637151617496356e-15 + 1.0000000000000002im\n\nSee also approximate for approximating a function on a curve or region.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.add_node!-Tuple{DiscretizedPath, Any}","page":"Functions","title":"RationalFunctionApproximation.add_node!","text":"add_node!(d::DiscretizedPath, idx)\n\nAdd a new node to the discretization, and return the indexes of all affected points. The indexes are valid on the points and params fields.\n\nArguments\n\nd: a DiscretizedPath object\nidx: a 2-element tuple, vector, or CartesianIndex into the params field. This identifies\n\nthe point to be promoted to a node.\n\nReturns\n\nA 2-element vector of CartesianIndices into the params and points fields.\n\nSee also DiscretizedPath, collect.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.approximate-Tuple{Function, ComplexRegions.AbstractRegion}","page":"Functions","title":"RationalFunctionApproximation.approximate","text":"approximate(f, domain)\n\nAdaptively compute a rational interpolant on a continuous or discrete domain.\n\nArguments\n\nContinuous domain\n\nf::Function: function to approximate\ndomain: curve, path, or region from ComplexRegions\n\nDiscrete domain\n\nf::Function: function to approximate\nz::AbstractVector: point set on which to approximate\n\nKeywords\n\nmax_iter::Integer=150: maximum number of iterations on node addition\nfloat_type::Type: floating point type to use for the computation¹\ntol::Real=1000*eps(float_type): relative tolerance for stopping\nallowed::Function: function to determine if a pole is allowed²\nrefinement::Integer=3: number of test points between adjacent nodes (continuum only)\nstagnation::Integer=20: number of iterations to determine stagnation\n\n¹Default of float_type is the promotion of float(1) and the float type of the domain. ²Default is to disallow poles on the curve or in the interior of a continuous domain, or to accept all poles on a discrete domain. Use allowed=true to allow all poles.\n\nReturns\n\nr::Approximation: the rational interpolant\n\nSee also Approximation, check, rewind.\n\nExamples\n\njulia> f = x -> tanh( 40*(x - 0.15) );\n\njulia> r = approximate(f, unit_interval)\nBarycentric{Float64, Float64} rational function of type (22, 22) on the domain: Path{Float64} with 1 curve\n\njulia> ( r(0.3), f(0.3) )\n(0.9999877116508015, 0.9999877116507956)\n\njulia> check(r);   # accuracy over the domain\n[ Info: Max error is 1.58e-13\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.check-Tuple{RationalFunctionApproximation.Approximation}","page":"Functions","title":"RationalFunctionApproximation.check","text":"check(r; quiet=false, prenodes=false)\n\nCheck the accuracy of a rational approximation r on its domain. Returns the test points and the error at those points.\n\nArguments\n\nr::Approximation: rational approximation\n\nKeywords\n\nquiet::Bool=false: suppress @info output\nprenodes::Bool=false: return prenodes of the approximation as well\n\nReturns\n\nτ::Vector: test points\nerr::Vector: error at test points\n\nSee also approximate.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.convergenceplot-Tuple{Any}","page":"Functions","title":"RationalFunctionApproximation.convergenceplot","text":"convergenceplot(r)\n\nPlot the convergence history of a rational approximation.\n\nMarkers show the maximum error on (the boundary of) the domain as a function of the numerator/denominator degree. A red marker indicates that the approximation has disallowed poles in its domain. A gold halo highlights the best approximation.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.decompose-Tuple{RationalFunctionApproximation.AbstractRationalInterpolant}","page":"Functions","title":"RationalFunctionApproximation.decompose","text":"decompose(r)\n\nReturn the roots, poles, and residues of the rational interpolant r.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.degree-Tuple{RationalFunctionApproximation.AbstractRationalInterpolant}","page":"Functions","title":"RationalFunctionApproximation.degree","text":"degree(r) returns the degree of the denominator of the rational r.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.degrees-Tuple{RationalFunctionApproximation.AbstractRationalInterpolant}","page":"Functions","title":"RationalFunctionApproximation.degrees","text":"degrees(r) returns the degrees of the numerator and denominator of the rational r.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.errorplot-Tuple{Any}","page":"Functions","title":"RationalFunctionApproximation.errorplot","text":"errorplot(r; use_abs=false)\n\nPlot the pointwise error of an Approximation on (the boundary of) its domain. If the error is not real, then the real and imaginary parts are plotted separately, unless use_abs=true.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.get_history-Union{Tuple{RationalFunctionApproximation.Approximation{T, S}}, Tuple{S}, Tuple{T}} where {T, S}","page":"Functions","title":"RationalFunctionApproximation.get_history","text":"get_history(r::Approximation)\n\nParse the convergence history of a rational approximation.\n\nArguments\n\nr::Approximation: the approximation to get the history from\n\nReturns\n\n::Vector: degrees of the approximations\n::Vector: estimated maximum errors of the approximations\n::Vector{Vector}: poles of the approximations\n::Vector{Vector}: allowed poles of the approximations\n::Integer: index of the best approximation\n\nSee also convergenceplot.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.minimax","page":"Functions","title":"RationalFunctionApproximation.minimax","text":"minimax(r::Barycentric, f::Function, nsteps::Integer=20)\nminimax(r::Approximation, nsteps::Integer=20)\n\nCompute an approximately minimax rational approximation to a function f on the nodes of a given rational function in barycentric form. The returned approximation has the same type as the first input argument.\n\nThe nsteps argument controls the number of Lawson iterations. The default value is 20.\n\nExamples\n\njulia> f(x) = tanh( 40*(x - 0.15) );\n\njulia> r = approximate(f, unit_interval, max_degree=8);  # least-squares approximation\n\njulia> check(r);\n[ Info: Max error is 1.06e-02\n\njulia> r̂ = minimax(r);\n\njulia> check(r̂);\n[ Info: Max error is 1.40e-03\n\n\n\n\n\n","category":"function"},{"location":"functions/#RationalFunctionApproximation.nodes-Tuple{RationalFunctionApproximation.AbstractRationalInterpolant}","page":"Functions","title":"RationalFunctionApproximation.nodes","text":"nodes(r) returns a vector of the interpolation nodes of the rational interpolant.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.poleplot-Tuple{Any}","page":"Functions","title":"RationalFunctionApproximation.poleplot","text":"poleplot(r, idx=0)\n\nPlot the domain of the approximation r and the poles of the rational approximant. If idx is nonzero, it should be an index into the convergence history of r.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.poles-Tuple{RationalFunctionApproximation.AbstractRationalInterpolant}","page":"Functions","title":"RationalFunctionApproximation.poles","text":"poles(r) returns the poles of the rational interpolant r.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.poles-Union{Tuple{Barycentric{T}}, Tuple{T}} where T","page":"Functions","title":"RationalFunctionApproximation.poles","text":"poles(r)\n\nReturn the poles of the rational function r.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.residues-Tuple{RationalFunctionApproximation.AbstractRationalInterpolant}","page":"Functions","title":"RationalFunctionApproximation.residues","text":"residues(r)\n\nReturns two vectors of the poles and residues of the rational function r.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.rewind-Tuple{RationalFunctionApproximation.Approximation, Integer}","page":"Functions","title":"RationalFunctionApproximation.rewind","text":"rewind(r, index)\n\nRewind a rational approximation to a state encountered during an iteration.\n\nArguments\n\nr::Approximation}: the approximation to rewind\nindex::Integer: the iteration number to rewind to\n\nReturns\n\nthe rational function of the specified index (same type as input)\n\nExamples\n\njulia> r = approximate(x -> cos(20x), unit_interval)\nBarycentric{Float64, Float64} rational interpolant of type (24, 24) on the domain: Path{Float64} with 1 curve\n\njulia> rewind(r, 10)\nBarycentric{Float64, Float64} rational interpolant of type (10, 10) on the domain: Path{Float64} with 1 curve\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.roots-Tuple{Barycentric}","page":"Functions","title":"RationalFunctionApproximation.roots","text":"roots(r)\n\nReturn the roots (zeros) of the rational function r.\n\n\n\n\n\n","category":"method"},{"location":"functions/#RationalFunctionApproximation.roots-Tuple{RationalFunctionApproximation.AbstractRationalInterpolant}","page":"Functions","title":"RationalFunctionApproximation.roots","text":"roots(r) returns the roots of the rational interpolant r.\n\n\n\n\n\n","category":"method"},{"location":"domains/#Approximation-on-domains","page":"Domains","title":"Approximation on domains","text":"","category":"section"},{"location":"domains/","page":"Domains","title":"Domains","text":"Rational approximations can be found on domains other than intervals using the ComplexRegions package.","category":"page"},{"location":"domains/#Unit-circle-and-disk","page":"Domains","title":"Unit circle and disk","text":"","category":"section"},{"location":"domains/","page":"Domains","title":"Domains","text":"The domain unit_circle is predefined. Here's a function approximated on the unit circle:","category":"page"},{"location":"domains/","page":"Domains","title":"Domains","text":"using RationalFunctionApproximation, CairoMakie, DomainColoring\nconst shg = current_figure\n\nf = z -> (z^3 - 1) / sin(z - 0.9 - 1im)\nr = approximate(f, unit_circle)","category":"page"},{"location":"domains/","page":"Domains","title":"Domains","text":"This approximation is accurate to 13 digits, as we can see by plotting the error around the circle:","category":"page"},{"location":"domains/","page":"Domains","title":"Domains","text":"errorplot(r)","category":"page"},{"location":"domains/","page":"Domains","title":"Domains","text":"Here is how the approximation looks in the complex plane (using a black cross to mark the pole):","category":"page"},{"location":"domains/","page":"Domains","title":"Domains","text":"using ComplexRegions, ComplexPlots\ndomaincolor(r, [-1.5, 1.5, -1.5, 1.5], abs=true)\nlines!(unit_circle, color=:white, linewidth=4)\nscatter!(poles(r), markersize=16, color=:black, marker=:xcross)\nlimits!(-1.5, 1.5, -1.5, 1.5)\nshg()","category":"page"},{"location":"domains/","page":"Domains","title":"Domains","text":"Above, you can also see the zeros at roots of unity.","category":"page"},{"location":"domains/","page":"Domains","title":"Domains","text":"This next function has infinitely many poles and an essential singularity inside the unit disk:","category":"page"},{"location":"domains/","page":"Domains","title":"Domains","text":"f = z -> tan(1 / z^4)\nr = approximate(f, unit_circle)\ndomaincolor(r, [-1.5, 1.5, -1.5, 1.5], abs=true)\nlines!(unit_circle, color=:white, linewidth=4)\nshg()","category":"page"},{"location":"domains/","page":"Domains","title":"Domains","text":"We can request an approximation that is analytic in a region. In this case, it would not make sense to request one on the unit disk, since the singularities are necessary:","category":"page"},{"location":"domains/","page":"Domains","title":"Domains","text":"r = approximate(f, unit_disk)","category":"page"},{"location":"domains/","page":"Domains","title":"Domains","text":"In the result above, the approximation is simply a constant function, as the algorithm could do no better. However, if we request analyticity in the region exterior to the circle, everything works out:","category":"page"},{"location":"domains/","page":"Domains","title":"Domains","text":"r = approximate(f, exterior(unit_circle))\nmax_err = maximum(abs, check(r, quiet=true)[2])\nprintln(\"Max error: \", max_err)","category":"page"},{"location":"domains/#Other-shapes","page":"Domains","title":"Other shapes","text":"","category":"section"},{"location":"domains/","page":"Domains","title":"Domains","text":"We are not limited to intervals and circles! There are other shapes available in ComplexRegions.Shapes:","category":"page"},{"location":"domains/","page":"Domains","title":"Domains","text":"import ComplexRegions.Shapes\nr = approximate(z -> log(0.35 + 0.4im - z), interior(Shapes.cross))\ndomaincolor(r, [-1.5, 1.5, -1.5, 1.5], abs=true)\nlines!(boundary(r.domain), color=:white, linewidth=4)\nshg()","category":"page"},{"location":"domains/","page":"Domains","title":"Domains","text":"c = Shapes.hypo(5)\nr = approximate(z -> (z+4)^(-3.5), interior(c))\ndomaincolor(r, [-5, 5, -5, 5], abs=true)\nlines!(c, color=:white, linewidth=4)\nshg()","category":"page"},{"location":"domains/","page":"Domains","title":"Domains","text":"Here are the predefined shapes:","category":"page"},{"location":"domains/","page":"Domains","title":"Domains","text":"shapes = [\n    Shapes.circle  Shapes.ellipse(2, 1) Shapes.squircle; \n    Shapes.square  Shapes.triangle      Shapes.cross;\n    Shapes.hypo(3) Shapes.star          Shapes.spiral(2, 0.7)\n    ]\n\nfig = Figure(size=(400, 400))\nfor i in 1:3, j in 1:3\n    ax, _ = lines(fig[i, j], shapes[i, j], linewidth=2, axis=(autolimitaspect=1,))\n    hidedecorations!(ax); hidespines!(ax)\nend\nresize_to_layout!(fig)\nshg()","category":"page"},{"location":"domains/#Unbounded-domains","page":"Domains","title":"Unbounded domains","text":"","category":"section"},{"location":"domains/","page":"Domains","title":"Domains","text":"It's also possible to approximate on domains with an unbounded boundary curve, but this capability is not yet automated. For example, the function","category":"page"},{"location":"domains/","page":"Domains","title":"Domains","text":"f = z -> 1 / sqrt(z - (-1 + 3im))","category":"page"},{"location":"domains/","page":"Domains","title":"Domains","text":"is analytic on the right half of the complex plane. In order to produce an approximation on that domain, we can transplant it to the unit disk via a Möbius transformation phi:","category":"page"},{"location":"domains/","page":"Domains","title":"Domains","text":"z = cispi.(range(-1, 1, length=90))           # points on the unit circle\nφ = Mobius( [-1, -1im, 1], [1im, 0, -1im])    # unit circle ↦ imag axis\nextrema(real, φ.(z))","category":"page"},{"location":"domains/","page":"Domains","title":"Domains","text":"By composing f with phi, we can approximate within the disk while f is evaluated only on its native domain:","category":"page"},{"location":"domains/","page":"Domains","title":"Domains","text":"r = approximate(f ∘ φ, interior(unit_circle))\ndomaincolor(r, [-2, 2, -2, 2], abs=true)\nlines!(unit_circle, color=:white, linewidth=4)\nscatter!(nodes(r.fun), color=:black, markersize=8)\nshg()","category":"page"},{"location":"domains/","page":"Domains","title":"Domains","text":"Above, the black markers show the nodes of the interpolant. We can view the same approximation within the right half-plane by composing r with phi^-1:","category":"page"},{"location":"domains/","page":"Domains","title":"Domains","text":"φ⁻¹ = inv(φ)\ndomaincolor(r ∘ φ⁻¹, [-8, 8, -8, 8], abs=true)\nlines!([(0, 8), (0, -8)], color=:white, linewidth=4)\nscatter!(φ.(nodes(r.fun)), color=:black, markersize=8)\nlimits!(-8, 8, -8, 8)\nshg()","category":"page"},{"location":"discrete/#Discrete-data","page":"Discrete data","title":"Discrete data","text":"","category":"section"},{"location":"discrete/","page":"Discrete data","title":"Discrete data","text":"The original AAA algorithm (Nakatsukasa, Sète, Trefethen 2018) works with a fixed set of points on the domain of approximation. There is a legacy aaa function that can work with this type of data:","category":"page"},{"location":"discrete/","page":"Discrete data","title":"Discrete data","text":"using RationalFunctionApproximation, ComplexRegions\nx = -1:0.01:1\nf = x -> tanh(5 * (x - 0.2))\nr = aaa(x, f.(x))","category":"page"},{"location":"discrete/","page":"Discrete data","title":"Discrete data","text":"However, it's preferable to use the approximate function for this purpose, as the result type is more useful within the package. Simply pass the function and, in the form of a vector, the domain.","category":"page"},{"location":"discrete/","page":"Discrete data","title":"Discrete data","text":"r = approximate(f, x)","category":"page"},{"location":"discrete/","page":"Discrete data","title":"Discrete data","text":"As long as there are no singularities as close to the domain as the sample points are to one another, this fully discrete approach should be fine:","category":"page"},{"location":"discrete/","page":"Discrete data","title":"Discrete data","text":"I = unit_interval\nprintln(\"nearest pole is $(minimum(dist(z, I) for z in poles(r))) away\")\n_, err = check(r);\nprintln(\"max error on the given domain: \", maximum(abs, err))","category":"page"},{"location":"discrete/","page":"Discrete data","title":"Discrete data","text":"But if the distance to a singularity is comparable to the sample spacing, the quality of the approximation may suffer. Even worse, the method may not be aware that it has failed.","category":"page"},{"location":"discrete/","page":"Discrete data","title":"Discrete data","text":"f = x -> tanh(400 * (x - 0.2))\nr = approximate(f, x)\nprintln(\"nearest pole is $(minimum(dist(z, I) for z in poles(r))) away\")\n_, err = check(r);\nprintln(\"max error on the given domain: \", maximum(abs, err))\nerr = maximum(abs(f(x)- r(x)) for x in range(-1, 1, 3000))\nprintln(\"max error on finer test points: \", err)","category":"page"},{"location":"discrete/","page":"Discrete data","title":"Discrete data","text":"In the continuous mode, the adaptive sampling of the domain attempts to ensure that the approximation is accurate everywhere.","category":"page"},{"location":"discrete/","page":"Discrete data","title":"Discrete data","text":"r = approximate(f, I; tol=1e-12)\nerr = maximum(abs(f(x)- r(x)) for x in range(-1, 1, 3000))\nprintln(\"max error on finer test points: \", err)","category":"page"},{"location":"python/#Usage-from-Python","page":"Usage from Python","title":"Usage from Python","text":"","category":"section"},{"location":"python/","page":"Usage from Python","title":"Usage from Python","text":"You can call the functions in this package from Python using the PythonCall/JuliaCall package. ","category":"page"},{"location":"python/#Installation","page":"Usage from Python","title":"Installation","text":"","category":"section"},{"location":"python/","page":"Usage from Python","title":"Usage from Python","text":"It's recommended to create a new virtual environment to try this out. In Python, you need to install juliacall via","category":"page"},{"location":"python/","page":"Usage from Python","title":"Usage from Python","text":"pip install juliacall","category":"page"},{"location":"python/","page":"Usage from Python","title":"Usage from Python","text":"Then, start Python and run:","category":"page"},{"location":"python/","page":"Usage from Python","title":"Usage from Python","text":"from juliacall import Main as jl","category":"page"},{"location":"python/","page":"Usage from Python","title":"Usage from Python","text":"This will download and initialize a copy of Julia. Finally, you need to install this package in that Julia environment:","category":"page"},{"location":"python/","page":"Usage from Python","title":"Usage from Python","text":"jl.seval('using Pkg; Pkg.add(\"RationalFunctionApproximation\")')","category":"page"},{"location":"python/","page":"Usage from Python","title":"Usage from Python","text":"That should be all you need to set up in the Python environment, although you may want to install ComplexRegions as well, depending on your use case.","category":"page"},{"location":"python/#Usage","page":"Usage from Python","title":"Usage","text":"","category":"section"},{"location":"python/","page":"Usage from Python","title":"Usage from Python","text":"In each new Python session, you need to load the packages as follows:","category":"page"},{"location":"python/","page":"Usage from Python","title":"Usage from Python","text":"from juliacall import Main as jl\njl.seval('using RationalFunctionApproximation, PythonCall')","category":"page"},{"location":"python/","page":"Usage from Python","title":"Usage from Python","text":"All the functions and constants exposed to Julia by this package are available using the jl object. For example, to use the discrete AAA algorithm:","category":"page"},{"location":"python/","page":"Usage from Python","title":"Usage from Python","text":"import numpy as np    # if installed in Python\nx = np.linspace(-1, 1, 1000)\ny = np.tanh(5 * (x - 0.2))\nr = jl.aaa(x, y)\nprint(r)","category":"page"},{"location":"python/","page":"Usage from Python","title":"Usage from Python","text":"Barycentric rational function of type (11,11)","category":"page"},{"location":"python/","page":"Usage from Python","title":"Usage from Python","text":"This will return a wrapped Julia object that you can use in Python as if it were a Python object. For example, you can evaluate the approximation at a point:","category":"page"},{"location":"python/","page":"Usage from Python","title":"Usage from Python","text":"r(0.5)","category":"page"},{"location":"python/","page":"Usage from Python","title":"Usage from Python","text":"0.9051482536448658","category":"page"},{"location":"python/","page":"Usage from Python","title":"Usage from Python","text":"If you want to apply the function at multiple points, you can use comprehensions, or you can vectorize the call in numpy:","category":"page"},{"location":"python/","page":"Usage from Python","title":"Usage from Python","text":"rv = np.vectorize(r)\nrv(np.array([0.5, 0.6, 0.7]))","category":"page"},{"location":"python/","page":"Usage from Python","title":"Usage from Python","text":"array([0.90514825, 0.96402758, 0.9866143 ])","category":"page"},{"location":"python/","page":"Usage from Python","title":"Usage from Python","text":"You can get information about the approximation using any documented function in the package, e.g.:","category":"page"},{"location":"python/","page":"Usage from Python","title":"Usage from Python","text":"print(jl.poles(r))    # returns wrapped Julia type","category":"page"},{"location":"python/","page":"Usage from Python","title":"Usage from Python","text":"ComplexF64[0.20000000000544785 - 0.31415926535542893im, 0.20000000000544788 + 0.31415926535542893im, 0.20000207991810143 - 0.942477292594254im, 0.20000207991810143 + 0.9424772925942541im, 0.20308324780986833 - 1.5724812056318853im, 0.20308324780986833 + 1.5724812056318853im, 0.29268586746842673 - 2.3408220889660796im, 0.29268586746842673 + 2.34082208896608im, 0.9695028397625358 + 4.390786420000105im, 0.969502839762536 - 4.390786420000105im, 21.59156666159181 + 0.0im]","category":"page"},{"location":"python/","page":"Usage from Python","title":"Usage from Python","text":"print(np.array(jl.poles(r)))    # converts to numpy array","category":"page"},{"location":"python/","page":"Usage from Python","title":"Usage from Python","text":"[ 0.2       -0.31415927j  0.2       +0.31415927j  0.20000208-0.94247729j\n  0.20000208+0.94247729j  0.20308325-1.57248121j  0.20308325+1.57248121j\n  0.29268587-2.34082209j  0.29268587+2.34082209j  0.96950284+4.39078642j\n  0.96950284-4.39078642j 21.59156666+0.j        ]","category":"page"},{"location":"python/#Passing-Python-functions","page":"Usage from Python","title":"Passing Python functions","text":"","category":"section"},{"location":"python/","page":"Usage from Python","title":"Usage from Python","text":"For function approximation, you can pass a Python function to the approximate package function.","category":"page"},{"location":"python/","page":"Usage from Python","title":"Usage from Python","text":"def f(x):\n    return np.tanh(5 * (x - 0.2))\n\nr = jl.approximate(f, jl.unit_interval)\nr(.5)","category":"page"},{"location":"python/","page":"Usage from Python","title":"Usage from Python","text":"0.9051482536448647","category":"page"},{"location":"#Rational-function-approximation-in-Julia","page":"Introduction","title":"Rational function approximation in Julia","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Documentation for RationalFunctionApproximation.jl.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This package computes rational approximations of a function or data given in the complex plane. For background reading, see [1], [2] (or the related arXiv version [3]), [4], and [5].","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A rational function is a ratio of two polynomials. Rational functions are capable of very high accuracy and, unlike polynomial interpolation, do not require the interpolation nodes to be distributed in a highly restricted way. They are a good choice for approximating functions with singularities or other complicated behavior. Also unlike polynomials, however, they do not depend linearly on the data, which has historically made them difficult to compute and work with.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Here's a smooth, gentle function on the interval -1 1:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using RationalFunctionApproximation, CairoMakie\nCairoMakie.update_theme!(size = (600, 400), fontsize=11)\nconst shg = current_figure\n\nf = x -> exp(cos(4x) - sin(3x))\nlines(-1..1, f)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To create a rational function that approximates f well on this domain, we make a call to the approximate function:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"r = approximate(f, unit_interval)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The value of unit_interval is defined by the package to be the interval -1 1. The result r is a type (19,19) rational approximant that can be evaluated like a function:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"f(0.5) - r(0.5)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We see that this approximation is accurate to about 13 places over the interval:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"z, err = check(r)\nlines(z, err)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The rational approximant interpolates f at nodes that were selected iteratively to represent the function well.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"x = nodes(r)\nscatter!(x, 0*x, markersize = 8, color=:black)\nshg()","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We could choose to approximate over a wider interval:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using ComplexRegions\nr = approximate(f, Segment(-2, 4))","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Note that the degree of the rational function increased to capture the additional complexity.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"One interesting feature of a rational function is that it can have poles, or infinite value, at the roots of the denominator polynomial. In this case, the poles hint at where the function is most sharply peaked:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"poleplot(r)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"More typically, however, a function that is well-behaved on the real axis has a singularity structure lurking in the complex plane, and the poles of rational functions provide a unique way to cope with them. For instance, let's try approximating the hyperbolic secant function:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"r = approximate(sech, Segment(-4, 4))","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The sech function is smooth on the real axis but has poles on the imaginary axis at odd multiples of ipi2. The rational approximant automatically locates the poles closest to the domain:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"2 * poles(r) / π","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We can use the DomainColoring package to visualize the rational function in the complex plane. Color is used to show the phase angle of the value, while dark-to-bright cycles of lightness show powers of e in the magnitude. The poles stand out as locations of rapid change in both phase and magnitude.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using DomainColoring\n\ndomaincolor(r, [-6, 6, -6, 6]; abs=true)\nlines!(r.domain, linewidth=3, color=:white)\nshg()","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A meromorphic function such as sech has only those isolated poles as singularities, and getting those right is most of the battle. By contrast, the function log(x + 005i) has a branch point at x = -005i necessitating a branch cut connecting it to infinity. A rational approximant uses poles to construct a proxy branch cut:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"f = x -> log(x + 0.05im)\nr = approximate(f, unit_interval)\ndomaincolor(r, [-1.2, 1.2, -1.2, 1.2]; abs=true)\nlines!(r.domain, linewidth=3, color=:white)\nshg()","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We close with a function having a singularity that lies on the interval: x. A famous result of Newman in 1964 proved that the best rational approximation of degree n has root-exponential convergence.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"r = approximate(abs, unit_interval; tol=1e-12)\nconvergenceplot(r)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(The errors increase for odd degrees above because they are being measured at the test points discovered at the end of the iteration, not the ones during the iteration.) We find that the nodes of the approximant are also distributed (nearly) root-exponentially around the singularity:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"z = filter(>(0), nodes(r))\nscatter(sort(abs.(z)), axis=(ylabel=\"| node |\", yscale=log10,))","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Algorithms describes the algorithms available for rational approximation.\nApproximation on domains shows how to approximate functions on different domains.\nDiscrete data shows how to approximate data given as points and values rather than as functions.\nMinimax approximation explains the difference between the default approximation and minimax approximation.\nUsage from Python shows how to use the package from Python.\nFunctions and types collects the documentation strings of the major package features.","category":"page"},{"location":"#References","page":"Introduction","title":"References","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Y. Nakatsukasa, O. Sète and L. N. Trefethen. The AAA Algorithm for Rational Approximation. SIAM Journal on Scientific Computing 40, A1494-A1522 (2018). Accessed on Jul 14, 2020.\n\n\n\nT. A. Driscoll, Y. Nakatsukasa and L. N. Trefethen. AAA Rational Approximation on a Continuum. SIAM Journal on Scientific Computing 46, A929-A952 (2024). Accessed on May 15, 2025.\n\n\n\nT. Driscoll, Y. Nakatsukasa and L. N. Trefethen. AAA Rational Approximation on a Continuum (2023). Accessed on Feb 26, 2024.\n\n\n\nS. Costa and L. N. Trefethen. AAA-least Squares Rational Approximation and Solution of Laplace Problems. In: European Congress of Mathematics, 1 Edition, edited by A. Hujdurović, K. Kutnar, D. Marušič, Š. Miklavič, T. Pisanski and P. Šparl (EMS Press, 2023); pp. 511–534. Accessed on Oct 5, 2023.\n\n\n\nO. S. Celis. Numerical Continued Fraction Interpolation. Ukrainian Mathematical Journal 76, 635–648 (2024). Accessed on Jan 28, 2025.\n\n\n\n","category":"page"},{"location":"minimax/#Minimax-approximation","page":"Minimax","title":"Minimax approximation","text":"","category":"section"},{"location":"minimax/","page":"Minimax","title":"Minimax","text":"The approximate function minimizes approximation error in a discrete least-squares sense. By following up with an iteratively reweighted least-squares (IRLS) approach initially due to Lawson, we can approach the classical problem of optimization in the infinity- or max-norm sense instead.","category":"page"},{"location":"minimax/","page":"Minimax","title":"Minimax","text":"For example, suppose we limit the degree of a rational interpolant of a smooth function:","category":"page"},{"location":"minimax/","page":"Minimax","title":"Minimax","text":"using RationalFunctionApproximation, CairoMakie\nconst shg = current_figure\nf = x -> exp(cos(4x) - sin(3x))\nr = approximate(f, unit_interval, max_iter=12)","category":"page"},{"location":"minimax/","page":"Minimax","title":"Minimax","text":"The error varies a lot in amplitude over the interval:","category":"page"},{"location":"minimax/","page":"Minimax","title":"Minimax","text":"errorplot(r)","category":"page"},{"location":"minimax/","page":"Minimax","title":"Minimax","text":"Now we apply 20 Lawson iterations to refine the approximation and approach the minimax ideal:","category":"page"},{"location":"minimax/","page":"Minimax","title":"Minimax","text":"r = minimax(r, 20)\nerrorplot(r)","category":"page"},{"location":"minimax/","page":"Minimax","title":"Minimax","text":"As you can see above, the error is now nearly equioscillatory over the interval. Moreover, the interpolation nodes appear to have shifted to resemble Chebyshev points of the first kind. If we try minimax approximation on the unit circle, however, equioscillation tends to lead to equally spaced nodes:","category":"page"},{"location":"minimax/","page":"Minimax","title":"Minimax","text":"f = z -> cos(4z) - sin(3z)\nr = approximate(f, unit_circle, max_iter=10)\nr = minimax(r, 20)\nerrorplot(r, use_abs=false)","category":"page"},{"location":"algorithms/#Algorithms","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"using RationalFunctionApproximation, CairoMakie","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"There are three algorithms for rational approximation offered in this version of the package. ","category":"page"},{"location":"algorithms/#AAA","page":"Algorithms","title":"AAA","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The most robust method is the continuum variant of the AAA algorithm (see also the arXiv version). Briefly speaking, the AAA algorithm maintains a set of interpolation nodes and a set of test points on the boundary of the domain. The node set is grown iteratively by finding the best current approximation in a least-squares sense on the test nodes, then greedily adding the worst-case test point to the node set.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The convergenceplot function shows the errors of the approximants found during the AAA iteration.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"f = x -> cos(11x)\nr = approximate(f, unit_interval)\nconvergenceplot(r)","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"(The plots in this documentation are made using CairoMakie, but the same functions are made available for Plots.)  In the plot above, the markers show the estimated max-norm error of the AAA rational interpolant over the domain as a function of the iteration counter. Each iteration adds one degree to both the numerator and denominator of the rational approximation. The gold halo indicates the final approximation chosen by the algorithm. The red dots indicate that a pole of the rational interpolant lies in the approximation domain. We can verify this fact by using rewind to recover the approximation from iteration 7:","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"r7 = rewind(r, 7)\npoles(r7)","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"In most cases, the poles move out of the approximation domain as the iteration proceeds to better accuracy. However, it is possible for the iteration to stagnate if the original function has a singularity very close to the domain.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"f = x -> tanh(3000*(x - 1//4))\nr = approximate(f, unit_interval)\nconvergenceplot(r)","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"This effect is thought to be mainly due to roundoff and conditioning of the problem. In this case, if we use more accurate floating-point arithmetic, we can see that the AAA convergence continues steadily past the previous plateau. In the following, we apply Double64 arithmetic, having used exact rational numbers already in the definition of f:","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"using DoubleFloats, ComplexRegions\nr = approximate(f, Segment{Double64}(-1, 1))\nconvergenceplot(r)","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"In the extreme case of a function with a singularity on the domain, the convergence can be substantially affected:","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"f = x -> abs(x - 1/8)\nr = approximate(f, unit_interval)\nconvergenceplot(r)","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"In such a case, we might get improvement by increasing the number of allowed consecutive failures via the stagnation keyword argument:","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"r = approximate(f, unit_interval, stagnation=50)\nconvergenceplot(r)","category":"page"},{"location":"algorithms/#Prescribed-poles","page":"Algorithms","title":"Prescribed poles","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"While finding a rational interpolant is a nonlinear problem, we can compute a linear variant if we prescribe the poles of the rational function. Specifically, given the poles zeta_1ldots zeta_n, we can find a polynomial p and residues w_k such that","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"f(z) approx p(z) + sum_k=1^n fracw_kz - zeta_k ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"When posed on a discrete set of test points, this is a linear least-squares problem. In order to represent the polynomial stably, an Arnoldi iteration is used to find a well-conditioned basis for the test points. ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"There is no iteration on the degree of the polynomial or rational parts of the approximant. Instead, the discretization of the boundary of the domain is refined iteratively until either the max-norm error is below a specified threshold or has stopped improving.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"f = x -> tanh(x)\nζ = 1im * π * [-1/2, 1/2, -3/2, 3/2]\nr = approximate(f, Segment(-2, 2), ζ)","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"max_err(r) = println(\"Max error: \", maximum(abs, check(r, quiet=true)[2]))\nmax_err(r);","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"To get greater accuracy, we can increase the degree of the polynomial part.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"r = approximate(f, Segment(-2, 2), ζ; degree=20)\nmax_err(r);","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Note that the residues (in the exact function, all equal to one) may be accurate at the poles closest to the domain, but much less so elsewhere.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Pair.(residues(r)...)","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Suppose now we approximate x using AAA. We can extract the poles of the result.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"r = approximate(abs, unit_interval, tol=1e-9)\nζ = poles(r)","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"To what extent might these poles be suitable for a different function that has the same singularity?","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"s = approximate(x -> exp(abs(x)), unit_interval, ζ; tol=1e-8, degree=20)\nmax_err(r);","category":"page"},{"location":"algorithms/#Thiele-continued-fractions-(experimental)","page":"Algorithms","title":"Thiele continued fractions (experimental)","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"The AAA algorithm is remarkably robust, but a potential downside is that constructing an approximant of degree n requires an SVD that takes O(n^3) time. Thus, for an iteration up to degree n, the work is O(n^4). In many cases, the value of n is small enough not to cause a concern, but there is some motivation to find a more efficient algorithm.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"One possibility is to use a continued fraction representation of the rational approximant. The Thiele representation, dating back to the 1800s, uses inverse divided differences to represent a rational interpolant, requiring just O(n) time to add a node to an approximation of degree n. Divided differences are notoriously unstable, but work by Salazar in 2024 (or the arXiv version) indicates that a greedy adaptive approach can reduce or eliminate the instability.  ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"To try greedy Thiele, use method=Thiele as an argument to approximate. ","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"f = x -> cos(11x - 5)\nr = approximate(f, unit_interval; method=Thiele)\nconvergenceplot(r)","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Some common functions give an error due to a division by zero that is not mathematically important. Until a mechanism is implemented to handle this situation more gracefully, you can usually circumvent this problem by adding a term that breaks some symmetry.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"f = x -> cos(11x)\ntry\n    r = approximate(f, unit_interval; method=Thiele)\ncatch err\n    println(\"Caught the error '$(err.msg)'\")\nend","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"f = x -> x + cos(11x)\nr = approximate(f, unit_interval; method=Thiele)\nmax_err(r);","category":"page"}]
}
